# -*- coding: utf-8 -*-
"""Project_Pipeline.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RXmIKxrNU-dnwGP6OXAcT2iXv_o6-Tnj

# **Data and Information Quality Project - AA 2025/2026**
Gruppo 13 - dataset 9 \
Silvia Ferrara, Alessia Mitrano, Vittorio La Rosa

![pipeline.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABHsAAADLCAYAAAD+1J+IAAABJ2lDQ1BrQ0dDb2xvclNwYWNlQWRvYmVSR0IxOTk4AAAokWNgYFJILCjIYRJgYMjNKykKcndSiIiMUmB/wcDFwMEgyGDOwJuYXFzgGBDgwwAEMBoVfLvGwAiiL+uCzMKUxwu4UlKLk4H0HyDOTi4oKmFgYMwAspXLSwpA7B4gWyQpG8xeAGIXAR0IZG8BsdMh7BNgNRD2HbCakCBnIPsDkM2XBGYzgeziS4ewBUBsqL0gIOiYkp+UqgDyvYahpaWFJol+IAhKUitKQLRzfkFlUWZ6RomCIzCkUhU885L1dBSMDIxMGBhA4Q5R/TkQHJ6MYmcQYgiAEJsjwcDgv5SBgeUPQsykl4FhgQ4DA/9UhJiaIQODgD4Dw745yaVFZVBjGJmMGRgI8QE8DkplNtElwQAAADhlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAEe6ADAAQAAAABAAAAywAAAAAkf4mSAABAAElEQVR4AeydB7wURdbFS9eEOa0REwqYFdMqJlDMmLNrzoqKaTGzmMOKETErKOYAZjFiVgxgAsw5BxRF0VX6q3+5NV+9pmemJ77peefye3RPd1c63V1ddevec6eKrBiJEBACQkAICAEhIASEgBAQAkJACAgBISAEhEBTIDB1U7RCjRACQkAICAEhIASEgBAQAkJACAgBISAEhIAQcAhI2aMHQQgIASEgBISAEBACQkAICAEhIASEgBAQAk2EgJQ9TXQz1RQhIASEgBAQAkJACAgBISAEhIAQEAJCQAhI2aNnQAgIASEgBISAEBACQkAICAEhIASEgBAQAk2EgJQ9TXQz1RQhIASEgBAQAkJACAgBISAEhIAQEAJCQAhI2aNnQAgIASEgBISAEBACQkAICAEhIASEgBAQAk2EgJQ9TXQz1RQhIASEgBAQAkJACAgBISAEhIAQEAJCQAhI2aNnQAgIASEgBISAEBACQkAICAEhIASEgBAQAk2EgJQ9TXQz1RQhIASEgBAQAkJACAgBISAEhIAQEAJCQAhMIwiEQC0R+P77780777yTK2LmmWc2HTp0MO3atcsda4SdeD1nnXVWs9hii5kZZpihEapXtzr88ssv5o477jBbbLGFmW222epWLgW9/vrrhvKRv/3tb2ahhRYy8847r/vt/6t1/T777DPTqVMnM2rUKLetdXm+XdoKASEgBISAEGhWBMLv+9RTT20WXHBBM//885upppqqYZs8fvx48/bbb5suXbqY6aabrqb1jI89Ki2sGmOXtOPiF154wUyaNMmsu+66lVY7Mf3BBx9sJk6caAYPHuzO17q8xErooBDIMAKy7MnwzctC1W+88Uaz+uqr5/6WXXZZM9NMM7kP/WGHHWb4mJQjkydPNt9++205SRPTxOu59NJLu3ruvvvu5ptvvklM0wwHaVsURbmmPProo4Y233XXXblj9drp3r177jlZddVVzXzzzWcWXXRRc9ttt+WqUOv6gQWDpN9++82VWevycg3TjhAQAkJACAiBJkUg/L6vttpqbgzI4t8//vEP88ADD5Td6mqPBcOKnHXWWW5MwgJYrSU+9qi0vGqMXdKOi1HGHHDAAZVWOW/633//3fz888+587UuL1eQdoRAkyAgZU+T3MhGbsZcc83ltP5o/j/++GPz2GOPmYMOOshp6Tt27Gieeuqpkqu/8847m+OPP77kdIUS+Hr++uuv5oMPPjADBgwwd999t/nnP/9ZKFlmz73xxhtOofLFF1/k2rDRRhuZ+++/32y//fa5Y/XcueCCC9yzghLwueeeM8sss4zZaaedzJNPPumqUe/61bu8emKtsoSAEBACQkAI1AsB/33/8ccfzauvvmquu+46M+OMM5pNN93U7LDDDi0WntLWqRZjQcr+888/zfXXX2+wQho0aFDa6jTMddUau6QZF3Mfb7nllrq1vd7l1a1hKkgI1AgBKXtqBKyy/X8E+FhOP/307g/XnG7dupkTTzzRuXdhyrvXXnsZFCylCIqjaouvJ65bWJSgkDr33HPNww8/bN5///1qF9fq+f33v/81rIqFgqnyJpts0mpudtNOO617TuaYYw63onbnnXc6d7qrrrrKVbPe9at3eeG90L4QEAJCQAgIgWZBwH/fcZNffvnlzbbbbmsef/xxM3DgQGfB67/zpbS3FmNByn/wwQfNV199Zc455xzzyCOPmE8//bSUarX6tdUau6QZF7Mot8IKK9StzfUur24NU0FCoEYIiLOnRsAq2+IIzDPPPObKK680Xbt2NZdddpk54ogjXCJcaDAfxbLj66+/dtwphx9+uFlggQXMmDFjzK233mrGjRvnPr79+vVzaf7973873+9CaYvXaMorvA8yvENwDWHpQxnUmdWFt956yymE5p57bnf8oYcecpYxEyZMcMqKAw880DDAQTh23nnnOSUSg4h77rnHvPzyywbrpt12283g4hYKbb3hhhuczzirXxtvvLFhFcuLzw+T1pdeeslx7ayzzjpmjz32cHXJhyHpL7nkEpeG/f79+5tZZpnF+VuvvPLKuTqGfDnvvfeeuemmm8ybb77pfNdXXHFFs++++7p05IGADUo7zLVvvvlm88wzz5g555zTtQ28yhGUhJh5e94n32YUcdQv/J0GU+5doXsUr2OYf7y81157zZmfY622yiqrGJ7ROMdTqeXFy9dvISAEhIAQEALNjADf8/vuu8/06dPH7LPPPs6ahvYWGgMVGwsWSpsGy2uvvdasv/76brx28sknu/Fe3Jq8lDFPKWNTrJ6GDh1qjjvuOLf4FdaXMRiu7cccc4xblGPsx7XvvvuuG4dglc1iZXzsQh5wEN17771ujMr4m/EiCrdSJWlczNhvxx13dFl5XDbffHM3LkRZhivWmmuu6caNcDKGwviO8TBjRuqONf1KK60UXtJi3+cfLy/t2LPU8loUrh9CIIMIyLIngzetmarMRB7FwejRo3PN8pY/HIC35dJLL3UdPx8vVnHGjh3ruH5++OEHt89vL4XS+mtK2aJsQlhJQPjIDBkyxFknPfvss+7jyUf8jz/+MFtttZXZf//9HdcPxIMMENZbbz1nDkxa6s8x0vNRos1LLbWUWzXChz30W2d/ueWWcwqZxRdf3LVzl112MWeffTZZOfH5cQylEmbHKB6QYjiwSgUhIMKHDwzh7/F5+nZzHqURqzZ8jBdeeGEz++yzG8yxuW+QF3oBG+4VbebjvuSSSxoUIgwMRowY4S8reUtdvCIsXj//Ow2mae5RvHI+f4+H/8193HPPPd2gFOu0U045xfTs2bNF8nLKa5GBfggBISAEhIAQaAMIwPnCmO6jjz5yrS02Bio0FiyWthic8EEy3tl1112dm9l2222X6MpVypin2JgsrBO8lowxyD8u//nPf5xijCAnp512mhtfffjhh25h7eKLL86NI/1YxY9dcI3v3LmzW5xs3769W7jr3bt3PPtUv32e4biYRVgvfpzMmPjMM890Y0YW7ihvww03zI2JuR7LLvJhy5gXZdYaa6yR2PYw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QEDKngLg6JQQEAJCQAgIASEgBISAEBACQkAICAEhIASyhoCUPVm7Y6qvEBACQkAICAEhIASEgBAQAkJACAgBISAECiAgZU8BcHRKCAgBISAEhIAQEAJCQAgIASEgBISAEBACWUNAyp6s3THVVwgIASEgBISAEBACQkAICAEhIASEgBAQAgUQkLKnADg6JQSEgBAQAkJACAgBISAEhIAQEAJCQAgIgawhIGVP1u6Y6isEhIAQEAJCQAgIASEgBISAEBACQkAICIECCEjZUwAcnRICQkAICAEhIASEgBAQAkJACAgBISAEhEDWEJCyJ2t3TPUVAkJACAgBISAEhIAQEAJCQAgIASEgBIRAAQSk7CkAjk4JASEgBISAEBACQkAICAEhIASEgBAQAkIgawhI2ZO1O6b6CgEhIASEgBAQAkJACAgBISAEhIAQEAJCoAACUvYUAEenhIAQEAJCQAgIASEgBISAEBACQkAICAEhkDUEpOzJ2h1TfYWAEBACQkAICAEhIASEgBAQAkJACAgBIVAAASl7CoCjU0JACAgBISAEhIAQEAJCQAgIASEgBISAEMgaAlL2ZO2Oqb5CQAgIASEgBISAEBACQkAICAEhIASEgBAogICUPQXA0SkhIASEgBAQAkJACAgBISAEhIAQEAJCQAhkDQEpe7J2x1RfISAEhIAQEAJCQAgIASEgBISAEBACQkAIFEBAyp4C4OiUEBACQkAICAEhIASEgBAQAkJACAgBISAEsoaAlD1Zu2OqrxAQAkJACAgBISAEhIAQEAJCQAgIASEgBAogIGVPAXB0SggIASEgBISAEBACQkAICAEhIASEgBAQAllDQMqerN0x1VcICAEhIASEgBAQAkJACAgBISAEhIAQEAIFEJCypwA4OiUEhIAQEAJCQAgIASEgBISAEBACQkAICIGsISBlT9bumOorBISAEBACQkAICAEhIASEgBAQAkJACAiBAghI2VMAHJ0SAkJACAgBISAEhIAQEAJCQAgIASEgBIRA1hCQsidrd0z1FQJCQAgIASEgBISAEBACQkAICAEhIASEQAEEpOwpAI5OCQEhIASEgBBIi8BHH31k3njjjbSX6zohIASEgBAQAkJACAgBIVAzBKapWc7KWAgIASEgBIRAiQgcdNBBZtKkSS7VjDPOaBZffHHTqVMns/HGG5tppmndT9aECRPM448/bh577DEzcuRIs+CCC5pll13WHHDAAWb++ec3d955p3niiSfMsGHDSmx1+Zdffvnl5uWXXzZXXHFF+ZkopRAQAkJACAgBISAEhEDTIdC6I+emg1MNEgJCQAgIgUoQuOGGG8xOO+1kOnToYL777jvz9NNPmzPOOMPMM8885pJLLjHdu3dPnf2vv/5qDjvsMHPRRReZdu3apU6XdCFWO2uvvbaZZZZZzAYbbGAOOeQQ89Zbb7n6bbHFFk7Zk5Su1sdmmGEGM9tss9W6GOUvBISAECgZgbG2j3z2hZHmq2++MTNMP72ZPHlyyXkogRAQAvkRmHrqqc2k334z8887r1lrjdVNR7tAJhECIQJS9oRoaF8ICAEhIARaHYE99tjDrLnmmrl6jB8/3vzrX/8ym2++uXOTWnTRRXPnCu1MnDjRXHXVVebcc8+tSNnz1VdfOQUPiqZBgwaZqaaaqlCxdT0HVhIhIASEQKMh8Jy1fhzx1NNmh222NosvtlijVU/1EQJNg0AUReatd941fU8/wxxzxOFmxeWWa5q2qSGVIyBlT+UYKgchIASEgBCoIQJzzDGHwV1p9OjRTulz22235UobNWqUGTFihPnNrmxhEeQVQa+++qp57rnn3HU33XSTs8jZbLPNzOyzz26+savMd999t/n888/NOuus4/4KKXBOOOEEs9BCC5mrr766ZEUPCifcvl566SXTuXNns91225npppsuV/9CdRk3bpz5/vvvzVJLLWUefPBB8+677zq3sa233jqX3l/TtWtXd2z48OGuHFzhHnnkEUP5m2yyiVl++eVzadgh3/vuu8+88847ZoUVVnBucrifUb/p7Qq8RAgIASFQLgJjbN910WWXm2sHXmKwPpQIASFQOwQYvyzZqaO54qILzQDr0j3LTDObxTtIwVo7xLOVswias3W/VFshIASEQJtE4G9/+5tzyfIKHEDo37+/s7h5/fXXDX9LLrmkOf/88x0+Y8eONQ888IDbRwFy1113Gdy6cL3CRQzFBoqWnXfe2ay11lruunz/PfXUU2bvvfcumTPoiy++cIqa3r17m08++cT06tXLKZZ+//13V1SxulB/LJpQSNEGFFsoY/r165erKtecc845ud+c69u3r0GxhXJoyJAhZtVVV3Vp/UVgteKKKzoFGphccMEF7vpdd93Vuc7567QVAkJA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YaG07sIy/4PT5uOPP87V0WdDXb788ktz2GGHmbvvvtux+W+++eZu/5FHHnGr02tasrd99923KO8Pk8ebbrrJuTMwwF/Rhl0l3SyzzOKLc/nSRjBjJf6tt94y5557rnN7KNT2QrjhLnHeeeeZgw46yMw777y5stLWhwgGuAbdfPPNbsIGx8Buu+3m6pjLTDuZQIBn4L777jN9+vQx++yzT85fnecHK7y3baQKXL423njjHD/NJZdcYl566SXXvv79+7vnFd4XngmkUFp3QYn/TZgwwT2vKKUol3dznXXWcRYihd4BX4x/T9M8s+SPBc+7NjoHSgisnnCtuPrqqw3KCuri+6Djjz/erb7zXeQ9fv75552lU8eOHc1mm23WggsnXxu23nrr3Lv4+OOPm4ceeshxCOyyyy7OtY10WF3Rt/CeYRUTd3krhHehfuCee+5x/deOO+7ooXITyrRt4dl57bXXzAMPPOD6SvDCIgurhCTBqmf99dd33EsfffSRuwSrrnxS6Dmr9n0nP9ynaAtuvGvZCQCcZnFJWy7X5euzi5XjnxXfP3M/6PeTBIUdzyiSlecgqR061hKBR594woy1BM07bbuNi9DV8qx+CQEhUA0Exr39jul7+umm77HHmKXsvEMiBEIEpg5/ZHEfv20mzk8++aS55pprzGmnnWZ69erl/OcZjK266qpuwg2RJxN0uAkgi2P7dxsakkn4EkssYbp06eIsNrbccktntdG3b1+3Uvzggw+6wQkDHsrijwGx/8siZqpzdRD4xz/+4ZQaISErVj8nnniiK2C++eZzz9BKK63kJlasRI4dO9a5dPzwww9un99eCqX115Sz5bk/6qijzO23355LzmB61113dZMxDjKJZJV6q622Mmeeeabj+WF1GjePDTfcsGAYWZRbuMEw4cI1BI4gXG1Q+DDB9uLLoJ3PPvusm4jwXiGF2l4INyYTJ598slOs+XJKqQ/WIOutt56bgEKmyoSPyf6IESN8dtpmCAHcaXi3/AScCS8WLCg+Fl98cffOoXw4++yzXav4dsC5gkCsy/sIrwpSLK27qMT//PNK+biiQeqLIhYp9A74YniH0jyzfAd5jj+0bm4oViBipj2URxu/+uorxyvDPn9813788Uf3LmC1CJkqPEi8vyiWTjjhBF8F15fxzsXb4NuGkpc+BBdYlG8oG3jf+bZS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)

# **Libraries:**
"""

!pip install recordlinkage

!pip install thefuzz

# Importing similarity distances libraries
!pip install pyphonetics jaro-winkler recordlinkage

# DataFrame manipulation:
import pandas as pd
# Numerical operations:
import numpy as np
# Handling timestamps with timezone awareness
from datetime import datetime, UTC
now = datetime.now(UTC)
# Base plotting library
import matplotlib.pyplot as plt

import seaborn as sns

# Regular expressions
import re
# Unicode normalization: remove accents, standardize text
import unicodedata
# Entity resolution/duplicate detection
import recordlinkage
from recordlinkage.datasets import load_febrl1
# Fuzzy matching/phonetics
from thefuzz import process, fuzz
import jellyfish

import missingno as mno

from collections import defaultdict
# Similarity distance
import jaro
from pyphonetics import Soundex
# Warnings
import warnings
warnings.filterwarnings("ignore", category=DeprecationWarning)
# Analysis
from sklearn.preprocessing import StandardScaler
import time as time
from sklearn.model_selection import ShuffleSplit, cross_val_score
from sklearn.model_selection import train_test_split
from sklearn.linear_model import Ridge
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import mean_squared_error, mean_absolute_error

"""**Dataset 9:**"""

# Loading the .csv file as a pandas DataFrame
url_dataset = "https://raw.githubusercontent.com/alemitrano/DIQ_Project_Gruppo13/main/Comune-di-Milano-Esercizi-di-vicinato-in-sede-fissa.csv"
ESE = pd.read_csv(url_dataset,sep=';',encoding='unicode_escape')

ese = ESE.copy()

"""# **Data Profiling & Quality Assessment**

**General dataset information**
"""

# Sizes of the dataset
print(f"Dataset sizes: {ESE.shape}\n")

# Dataset's columns
columns = list(ESE.columns)
print(f"Dataset columns: {columns}\n")

# Dataset's types
print(f"Dataset columns types:\n{ESE.dtypes}\n")

# Printing numerical and categorical columns
numeric_cols = ESE.select_dtypes(include=['float64', 'int64']).columns
categorical_cols = ESE.select_dtypes(include=['object']).columns

print(f"\nColonne Numeriche: {list(numeric_cols)}")
print(f"Colonne Categoriche: {list(categorical_cols)}")

"""**Dataset data duplication level**"""

# Checking how many duplicated rows are in the dataset
print("Total number of exactly duplicated rows: ", ESE.duplicated().sum())

# Printing the number of distinct elements for each column and the distinct values
print("\nNumber of distinct values by columns:\n")
columns = list(ESE.columns)
num_distinct_elems = [[col, ESE[col].nunique()] for col in columns]

for elem in num_distinct_elems:
    if elem[1] <= 20:
      print(f"{elem[0]}: {elem[1]} -> {ESE[elem[0]].unique()}")
    else:
      print(f"{elem[0]}: {elem[1]}")

# Given the large number of distinct values in Settore Storico Cf Preval, despite fewer expected, we list them
display(pd.Series(ESE['Settore Storico Cf Preval'].unique()))

"""**Null values**"""

# Show whether an attribute of a certain row of the dataset is NULL or not
ESE.isnull()

# Display the number of NULL values for each column
NULL_VAL_PER_COL = ESE.isnull().sum()
print(f"Number of NULL values for each column:\n\n{NULL_VAL_PER_COL}")

"""**Accuracy evaluation**\
We check for syntactic accuracy

Accuracy for "ZD" column:
"""

#Calculate di accuracy of the ZD column
ZD_domain = [1,2,3,4,5,6,7,8,9]
correct_ZD = ESE['ZD'].isin(ZD_domain).sum()
not_null_ZD = ESE['ZD'].count()
accuracy = correct_ZD/not_null_ZD
print(f"Accuracy of the ZD column: {accuracy*100}%")

"""Accuracy for "Codice Via" column:"""

#Calculate the accuracy of the column 'Codice via' by checking that the code is composed of 3 or 4 digits
temp_codice = pd.to_numeric(ESE['Codice via'], errors='coerce').fillna(0)   # temporary copy

correct_codice_via = temp_codice.between(100, 9999).sum()
not_null_codice_via = ESE['Codice via'].count()

accuracy = correct_codice_via/not_null_codice_via
print(f"Accuracy: {accuracy*100}%")

"""**Completeness evaluation**"""

# Completeness evaluation
total_cells = ESE.size
missing_cells = ESE.isnull().sum().sum()
completeness_ratio = (1 - (missing_cells / total_cells)) * 100

print(f"Overall Dataset Completeness: {completeness_ratio:.2f}%")

# By column
missing_df = pd.DataFrame({'Missing Values': ESE.isnull().sum(), 'Percentage': (ESE.isnull().sum() / len(ESE)) * 100
}).sort_values(by='Percentage', ascending=False)

print("\nCritical columns:")
print(missing_df[missing_df['Percentage'] > 0])

# Graphic visualisation
print('\n')
plt.figure(figsize=(10, 6))
sns.barplot(x=missing_df.index, y=missing_df['Percentage'], palette="Reds_r")
plt.xticks(rotation=90)
plt.title("Completeness Analysis per attribute")
plt.ylabel("% Missing Values")
plt.show()

"""**Consistency Evaluation** \
For what concern the consistency, we check whether some integrity contraints referred to some columns of the dataset are respected. \
In particular we check:
1. If the values in the "Superficie Totale" column are greater than 0 (it wouldn't make sense to have a negative surface)
2. Address information contained in the column 'Ubicazione' are the same of the respective columns.
"""

# Creating an array of the columns that will represent whether a row in the dataset has passed a specific consistency check.
PROPERTIES = ["Consistency Superficie Totale", "Consistency Tipo via", "Consistency Via", "Consistency Civico", "Consistency ZD"]

NEW_DF = ESE.copy() # working on a copy of dataset - those columns are just for analysis

# Adding the new columns and populate the rows with '1' if the check has been passed, with '0' otherwise
# N.B: In case the processed row contains a NULL value, in the consistency column we decided to put a '0' value
NEW_DF[PROPERTIES[0]] = np.where(NEW_DF['Superficie Totale']>0.0,
                                      1,
                                      0)
NEW_DF[PROPERTIES[1]] = np.where(NEW_DF['Ubicazione'].str.split(" ").str[0] == NEW_DF['Tipo via'],
                                      1,
                                      0)
NEW_DF[PROPERTIES[2]] = np.where(NEW_DF.apply(lambda row: str(row['Via']) in str(row['Ubicazione']), axis=1),
                                      1,
                                      0)
NEW_DF[PROPERTIES[3]] = np.where(NEW_DF['Ubicazione'].str.extract(r'(?:N.|n.|num.|civ.)\s*(\d+)', expand=False) == NEW_DF['Civico'],
                                      1,
                                      0)
NEW_DF[PROPERTIES[4]] = np.where(NEW_DF['Ubicazione'].str.extract(r'z.d. (\d+)', expand=False).astype(float) == NEW_DF['ZD'],
                                      1,
                                      0)
NEW_DF

# Computing and display the consistency of the columns on which we put the constaints
for cons in PROPERTIES:
  # Retrieving the column name present in the original dataset
  COL_NAME = cons.split("Consistency ")[1]
  # Computing the number of consistent cells w.r.t. a certain column in the dataset
  CONSISTENT_CELLS = (NEW_DF[cons] == 1).sum()

  # Retrieving the total number of rows in the dataset
  TOTAL_CELLS = NEW_DF.shape[0]

  # Computing the consistency of the COL_NAME column and print it
  # N.B: In the consistency computation we consider that NULL cell do not pass the consistency checks
  CONSISTENCY = CONSISTENT_CELLS / TOTAL_CELLS
  CONSISTENCY = '{0:.1f}%'.format(CONSISTENCY * 100)
  print(f"{cons}: " + CONSISTENCY)

"""# **Data Cleaning**

## **Data Transformation/Standardization**

**Fields standardization**
"""

# Trasforming every field in uppercase:
ESE = ESE.apply(lambda col: col.str.upper() if col.dtype == "object" else col)

"""**Data types normalization**

Normalize "*Insegna*" column:
"""

ese_insegna = ESE.copy()

def norm(s):
    if pd.isna(s):
        return s
    return re.sub(r"[^A-Z0-9]+", " ", str(s).upper()).strip()

ese_insegna["Insegna_norm"] = ese_insegna["Insegna"].map(norm)

# chiave compatta: unisce solo differenze di spazi/punteggiatura
ese_insegna["key"] = ese_insegna["Insegna_norm"].str.replace(" ", "", regex=False)

# canonico = versione pi frequente per quella key
rep = ese_insegna.groupby("key")["Insegna_norm"].agg(lambda x: x.value_counts().idxmax()).to_dict()

ESE["Insegna"] = ese_insegna["key"].map(rep)

"""Normalize "*Codice via*" column:"""

# Normalizing column:
ESE['codice_via'] = pd.to_numeric(ESE['Codice via'], errors='coerce').astype('Int64')


print(f"Tipo colonna nuova 'codice_via': {ESE['codice_via'].dtype}")

# Removing original column to avoid semantic duplications
ESE = ESE.drop(columns=['Codice via'])

"""**Fields extraction from "Ubicazione"**

Extract "Tipo via", "Via", "Civico", "ZD" from "*Ubicazione*":
"""

# Pattern Indirizzo: Cattura la prima parola (Tipo), tutto ci che c' in mezzo (Via), e il numero dopo "N." (Civico)
regex_indirizzo = r'^(?P<Tipo_estratto>\w+)\s+(?P<Via_estratta>.+?)\s+N\.\s*(?P<Civico_estratto>[0-9/a-zA-Z-]+)'

# Pattern ZD: Cerca "z.d." seguito da un numero
regex_zd = r'z\.d\.\s*(?P<ZD_estratta>\d+)'


print("Extracting data from 'Ubicazione'...")

# Extracting Address (Tipo, Via, Civico)
extracted_addr = ESE['Ubicazione'].str.extract(regex_indirizzo, flags=re.IGNORECASE)

# Extracting ZD
extracted_zd = ESE['Ubicazione'].str.extract(regex_zd, flags=re.IGNORECASE)


# Standardizziamo il testo estratto (tutto minuscolo e senza spazi extra)
#for col in ['Tipo_estratto', 'Via_estratta', 'Civico_estratto']:
 #   if col in extracted_addr.columns:
  #      extracted_addr[col] = extracted_addr[col].str.lower().str.strip()

# Conversion of ZD as a number
extracted_zd['ZD_estratta'] = pd.to_numeric(extracted_zd['ZD_estratta'], errors='coerce')


# Tipo via
ESE['Tipo via'] = extracted_addr['Tipo_estratto'].fillna(ESE['Tipo via'])

# Via
ESE['Via'] = extracted_addr['Via_estratta'].fillna(ESE['Via'])

# Civico
ESE['Civico'] = extracted_addr['Civico_estratto'].fillna(ESE['Civico'])

# ZD
ESE['ZD'] = extracted_zd['ZD_estratta'].fillna(ESE['ZD'])

print("Update completed.")
print("\nData examples (Ubicazione vs new columns):")
cols_to_check = ['Ubicazione', 'Tipo via', 'Via', 'Civico', 'ZD']
display(ESE[cols_to_check].head(10))

"""**Integrity check for extracted fields from "Ubicazione"**

Verify that all tuples have a **valid ZD value** (between 1 and 9):
"""

# Intregrity Check: verify that all tuples have a valid ZD between 1 and 9

# Excluding NaN (those are a Completeness problem)
mask_valid = (ESE['ZD'] >= 1) & (ESE['ZD'] <= 9)
mask_invalid = (ESE['ZD'].notnull()) & (~mask_valid)

num_invalid = mask_invalid.sum()
values_invalid = ESE.loc[mask_invalid, 'ZD'].unique()

print(f"Check correct range ZD [1-9]:")
print(f" - Compliant rows: {mask_valid.sum()}")
print(f" - NOT Compliant rows: {num_invalid}")

if num_invalid > 0:
    print(f" - Uncorrect values: {values_invalid}")
    display(ESE[mask_invalid][['Insegna', 'Via', 'Civico', 'ZD']])
else:
    print("SUCCESS: ZD column has all valid values!")

"""Display all the rows in which **"ZD" is NULL**:"""

# Display all the rows in which "ZD" is NULL
mask = ESE["ZD"].isnull()
ESE[mask]

"""**Consistency check for columns extracted from "Ubicazione"**

Checking unconsistency in "Tipo via" column:
"""

# Check unconsistency in "Tipo via" column
split = ESE["Ubicazione"].str.split(" ")
tipo_via = split.str[0]

# Show rows where "Tipo via" is not consistent
mask = (ESE["Tipo via"] != tipo_via) & (tipo_via.notnull())
ESE[mask]

"""**New columns extraction from "Ubicazione"**

Extracting "Accesso" column:
"""

# Extract "Accesso" from column "Ubicazione"
ESE["Accesso"] = ESE["Ubicazione"].str.split("ACCESSO: ").str[1].str.split(";").str[0]
ESE["Accesso"].value_counts()

print(ESE["Accesso"].value_counts().sum())

"""Extracting "Isolato" column:"""

# Extract "Isolato" from "Ubicazione" column
ESE["Isolato"] = (
    ESE["Ubicazione"]
    .str.extract(r'ISOLATO:\s*(\d+)')[0]
    .fillna("NON SPECIFICATO")
)

ESE["Isolato"].value_counts()

print(ESE["Isolato"].value_counts().sum())

"""Extracting "Ingresso" column:"""

# Extract "Ingresso" from "Ubicazione"
ESE["Ingresso"] = ESE["Ubicazione"].astype(str).str.split("INGRESSO").str[1].str.strip().str.split(";").str[0].str.replace(r" \(z.d. \d\)", "", regex=True)
ESE["Ingresso"].value_counts()

print(ESE["Ingresso"].value_counts().sum())

"""Since, as shown below, there are very few rows with a "presso" field, we do not extract a column for it:"""

# See how many rows has 'presso' inside the "Ubicazione" column
ESE["Ubicazione"].str.contains("PRESSO").sum()

# Current dataframe with all the new columns
ESE.iloc[10:15]

"""**Columns names transformation**"""

# Columns names transfromation
ESE.columns = (
    ESE.columns.str.strip()
               .str.lower()
               .str.replace(r"\s+", "_", regex=True)
)

# Check the transformation of the columns
ESE.columns

"""**Normalization of *Settore Storico Cf Preval* column:**"""

def normalize(x):
# Keep NaN as NaN (do not convert missing to empty strings), otherwise downstream cleaning/matching may re-create missing values.
    if pd.isna(x):
        return np.nan
    x = str(x)
    x = re.sub(r"[^\w\s]", " ", x)        # rimuove punteggiatura
    x = re.sub(r"\s+", " ", x).strip()    # normalizza spazi
    return x if x else np.nan             # evita stringhe vuote

ESE["clean_settore"] = ESE["settore_storico_cf_preval"].apply(normalize)

# Remove typos in the new "settore storico":
ESE['clean_settore'] = ESE['clean_settore'].str.removesuffix(',an')

"""**Normalization of *Settore Merceologico* column:**"""

# Normalize text (uppercase, remove spurious separators, trim)
def normalize_label(x):
    if pd.isna(x):
        return np.nan
    x = str(x).upper().strip()
    # split on separators like ';' ',' and re-join unique tokens
    parts = [p.strip() for p in re.split(r"[;,]+", x) if p and p.strip()]
    parts = list(dict.fromkeys(parts))  # remove duplicates preserving order
    return ";".join(parts) if parts else np.nan

ESE["settore_merceologico"] = ESE["settore_merceologico"].apply(normalize_label)

"""**Elimination of redundant information**

After text normalization, the above ***cleaned sector label*** replaces the original field "**Settore Storico Cf Preval**", which is removed to avoid redundancy and ensure the use of a single canonical representation:
"""

ESE = ESE.drop(columns=["settore_storico_cf_preval"])

"""Since each information in "**Ubicazione**" has been already extracted into new columns "Ingresso", "Isolato", "Accesso", it's possible to **drop** this column since it now contains redundant information"""

# Removing Ubicazione
ESE.drop(columns=['ubicazione'], inplace=True)

print("Actual columns in the dataset:")
print(ESE.columns.tolist())

"""## **Error Detection and Correction**

**Error** **Detection** on ***superfici*** values: \
Clearly impossible values (e.g., negative surfaces, total surface smaller than selling surface, inconsistent component sums) were identified as data errors.
"""

# No negative values in Superfici
cols_area = ["superficie_vendita", "superficie_altri_usi", "superficie_tabelle_speciali", "superficie_totale"]

for c in cols_area:
    print(c, (ESE[c] < 0).sum())

# Superficie totale < vendita (violazione di vincolo)
mask_incoerente = (ESE["superficie_totale"] < ESE["superficie_vendita"])

mask_incoerente.sum()

# Totale = 0 ma vendita > 0
mask_zero_tot = ((ESE["superficie_totale"] == 0) & (ESE["superficie_vendita"] > 0))

mask_zero_tot.sum()

"""**Error detection** on ***civico*** column:"""

# Civico 0
ESE.loc[ESE["civico"].isin(["0", 0])]

# Civico con caratteri strani (es. solo lettere o simboli) - esclusi i NaN
mask_civico_only_letters = (ESE["civico"].notna() & ESE["civico"].astype(str).str.strip().str.fullmatch(r"[A-Za-z]+"))

mask_civico_only_letters.sum()

ESE.loc[mask_civico_only_letters,["civico", "tipo_via", "via", "insegna"]].head(30)

"""> **Correction** on **"*civico*":** \
Values composed exclusively of alphabetic characters in the attribute civico were identified as domain errors and replaced with an explicit placeholder (S.N.C.), while alphanumeric civic numbers (e.g., 3/A) were preserved.
"""

# Correcting "Civico"
ESE.loc[mask_civico_only_letters, "civico"] = "S.N.C."

ESE["civico"].astype(str).str.strip().str.fullmatch(r"[A-Za-z]+").sum()

"""**Error detection** on ***tipo_via***:"""

# Check Errore: tipo_via composto SOLO da numeri
mask_tipo_via_only_numbers = (ESE["tipo_via"].astype(str).str.strip().str.fullmatch(r"\d+"))
mask_tipo_via_only_numbers.sum()

ESE.loc[mask_tipo_via_only_numbers, ["tipo_via", "via", "civico", "insegna"]].head(20)

"""> **Correction** on **"*tipo via*":** \
A **single** error occurence has emerged. Since the correct information is available and readable, we proceeded with a manual correction of the Tipo Via, Via and Civico fields to recover the record, avoiding having to discard it
"""

# Correcting numerical tipo via
print("\nPoisoned row(s) with numerical 'tipo_via':\n")
poisoned_tipovia = ESE.loc[mask_tipo_via_only_numbers].copy()
display(poisoned_tipovia)


idx_da_correggere = poisoned_tipovia.index[0]

ESE.at[idx_da_correggere, "settore_merceologico"] = "NON ALIMENTARE"
ESE.at[idx_da_correggere, "insegna"] = "Non specificato"
ESE.at[idx_da_correggere, "tipo_via"] = "VIA"
ESE.at[idx_da_correggere, "via"] = "GROSOTTO"
ESE.at[idx_da_correggere, "civico"] = "7"
ESE.at[idx_da_correggere, "zd"] = 8
ESE.at[idx_da_correggere, "codice_via"] = 7328

print("\nAfter the correction:")
display(ESE.loc[[idx_da_correggere]])

"""**Error detection** on ***via*** column:"""

# Check Errore: via composta SOLO da numeri
mask_via_only_numbers = (ESE["via"].astype(str).str.strip().str.fullmatch(r"\d+"))

mask_via_only_numbers.sum()
ESE.loc[mask_via_only_numbers,["via", "tipo_via", "civico", "insegna"]].head(20)

"""> **Correction** on **"*via*":** \
Very few records exhibiting severe address parsing errors (purely numeric street name, missing street type, and inconsistent shop name) were **removed** from the dataset. Given the absence of sufficient contextual information to reliably reconstruct the correct address, record deletion was preferred over arbitrary correction in order to preserve data integrity.
"""

# mostra il record con via composta solo da numeri (poisoned)
print("\nPoisoned row with numerical 'via'\n:")
poisoned_rows = ESE.loc[mask_via_only_numbers]
display(poisoned_rows)

# deleting
ESE = ESE.drop(index=poisoned_rows.index)
print("\nPoisoned row with numerical 'via' deleted.")

"""**Error detection** on ***insegna*** column:"""

# righe in cui insegna contiene solamente numeri
mask_num_insegna = (ESE["insegna"].astype(str).str.strip().str.fullmatch(r"\d+"))

mask_num_insegna.sum()

ESE.loc[mask_num_insegna, ["insegna", "tipo_via", "via", "civico"]].head(20)

"""> **Correction** on **"*Insegna*":** \
Purely numeric values in the attribute insegna were identified as parsing errors and treated as missing, while alphanumeric shop names were preserved.
"""

# Correcting "Insegna"
ESE.loc[mask_num_insegna, "insegna"] = "Non specificato"
ESE["insegna"].astype(str).str.strip().str.fullmatch(r"\d+").sum()

"""## **Missing values**"""

# Visualizing missing cells
mno.matrix(ESE)

# Printing the number of NULL values in each dataset column
ESE.isnull().sum()

"""Fill rows that have a NULL "***civico***" with 'S.N.C.' ('Senza Numero Civico')"""

# Fill rows that have a NULL "Civico" with 'S.N.C.' ('Senza Numero Civico')
ESE["civico"] = ESE["civico"].fillna("S.N.C.")
ESE[ESE["civico"].isnull()]

"""Missing values in ***settore_prevalente*** :"""

# Missing values: settore_storico_cf_preval

# Identifica le righe con settore_storico_cf_preval mancante
mask = ESE["clean_settore"].isna()

# Si assegna un placeholder neutro per evitare imputazioni premature
ESE.loc[mask, "clean_settore"] = "SETTORE NON SPECIFICATO"

ESE["clean_settore"].isna().sum()

"""Missing values in ***settore_merceologico***:"""

# Missing values: settore_merceologico
mask = ESE["settore_merceologico"].isna()
ESE.loc[mask, "settore_merceologico"] = "NON SPECIFICATO"

ESE["settore_merceologico"].isna().sum()

"""Missing values in ***codice_via***:"""

# Visualize the record with missing codice_via
missing_codice_via = ESE.loc[ESE["codice_via"].isna()]

print(f"Number of records with missing codice_via: {len(missing_codice_via)}")
display(missing_codice_via)

"""> Since it's an informationless record (majority of values are null) we drop it:"""

ESE = ESE.dropna(subset=["codice_via"])
ESE["codice_via"].isna().sum()

"""Filling other columns:"""

ESE["insegna"] = ESE["insegna"].fillna("Non specificata")
ESE["accesso"] = ESE["accesso"].fillna("Non specificato")
ESE["ingresso"] = ESE["ingresso"].fillna("Non specificato")
ESE["isolato"] = ESE["isolato"].fillna(0)
ESE.isnull().sum()

"""Check ***zd*** column missing values:"""

ESE.loc[ESE["zd"].isna(), :]

# Final check on overall missing values
ESE.isnull().sum()

"""## **Data Deduplication - Data Fusion**

Removing redundant information (**exactly duplicated rows**)
"""

# Number of exactly duplicated rows
num_duplicates = ESE.duplicated().sum()
print("Exact duplicates:", num_duplicates)

# ELIMINAZIONE
ese_dedup = ESE.drop_duplicates(keep='first').reset_index(drop=True)
print("Dataset after removing exactly duplicated rows: ", ese_dedup.shape)

"""Imposing a correct value correlation in "**Superficie Totale**", as the resulting sum of  "**Superficie Vendita**", "**Superficie Altri Usi**", "**Superficie Tabelle Speciali**":

"""

# Printing min and max values of 'Superficie Totale' column
print('Superficie MIN:', ese_dedup['superficie_totale'].min())
print('Superficie MAX:', ese_dedup['superficie_totale'].max())

cols_superficie = ['superficie_vendita', 'superficie_altri_usi', 'superficie_tabelle_speciali', 'superficie_totale']

print("\n Missing Values \n\n")
print(ese_dedup[cols_superficie].isnull().sum())

# Counting 0 values
num_zeri = (ese_dedup['superficie_totale'] == 0).sum()
print(f"\nValori pari a 0 in Superficie Totale: {num_zeri}")
num_zeri = (ese_dedup['superficie_vendita'] == 0).sum()
print(f"Valori pari a 0 in Superficie Vendita: {num_zeri}")
num_zeri = (ese_dedup['superficie_altri_usi'] == 0).sum()
print(f"Valori pari a 0 in Superficie Altri Usi: {num_zeri}")
num_zeri = (ese_dedup['superficie_tabelle_speciali'] == 0).sum()
print(f"Valori pari a 0 in Superficie Tabelle Speciali: {num_zeri}")


# debug to show some examples
print("\nEsempio di negozi con superficie 0:")
display(ese_dedup[ese_dedup['superficie_totale'] == 0][['insegna', 'via', 'settore_merceologico', 'superficie_totale']].head())

ese_check = ese_dedup[cols_superficie].fillna(0)  # NaN = 0

ese_check['Somma_Calcolata'] = (ese_check['superficie_vendita'] +
                               ese_check['superficie_altri_usi'] +
                               ese_check['superficie_tabelle_speciali'])

mask_corretta = abs(ese_check['superficie_totale'] - ese_check['Somma_Calcolata']) == 0

print(f"Totale Righe: {len(ese_dedup)}")
print(f"Righe Coerenti: {mask_corretta.sum()}")
print(f"Righe Incoerenti: {(~mask_corretta).sum()}")

# debug
df_errori = ese_check[~mask_corretta]
print("\nEsempio di errori:")
display(df_errori.head())

"""> Since the majority of rows show "Superficie Totale" as the sum between "Superficie Vendita", "Superficie Altri Usi" and "Superficie Tabelle Speciali", we have decided to apply this rule for the entire "Superficie Totale" column, thus respecting the dataset overall coherence:"""

# Interested Columns:
cols_parti = ['superficie_vendita', 'superficie_altri_usi', 'superficie_tabelle_speciali']
col_totale = 'superficie_totale'

# To be able to perform mathematical calculations on the entire dataset, we assume that NaN means 0 square meters
cols_tutte = cols_parti + [col_totale]
ese_dedup[cols_tutte] = ese_dedup[cols_tutte].fillna(0)

# GLOBAL RECALCULATION : let's recalculate the Total for EVERY row
ese_dedup[col_totale] = ese_dedup[cols_parti].sum(axis=1)

print("Total recalculated for the entire dataset.")

check_mismatch = (abs(ese_dedup[col_totale] - ese_dedup[cols_parti].sum(axis=1)) > 0).sum()
print(f"\nFinal check, number of inconsistencies: {check_mismatch}")

# debug:
print("Clear data example:")
display(ese_dedup[cols_tutte].sample(5))

"""**Fixing values in columns "Settore Merceologico" and "Settore Storico Cf Prevalente"**

> Let's see what's inside "Settore Merceologico":
"""

# Let's see what's inside "Settore Merceologico" - to show that it's a mess:
print(ese_dedup['settore_merceologico'].value_counts())

"""> Let's show the existing *uncorrect* correlations between "Settore Merceologico" and "Settore Storico Cf Preval" columns:"""

# COHERENCE ANALISYS SECTORS "Settore Merceologico" e "Settore Storico Cf Preval"
analisi_coerenza = pd.crosstab(
    index=ese_dedup['settore_merceologico'],
    columns=ese_dedup['clean_settore'].fillna('MANCANTE'),
    margins=True,
    margins_name="Totale"
)


print("Analisi incrociata: Settore Merceologico vs Settore Storico")
print("-" * 60)

for settore_macro in analisi_coerenza.index:
    if settore_macro == "Totale": continue

    print(f"\nMACRO-SETTORE: '{settore_macro.upper()}'")


    dettagli = analisi_coerenza.loc[settore_macro]
    dettagli_presenti = dettagli[dettagli > 0].sort_values(ascending=False)

    # sottosettori trovati
    for storico, conteggio in dettagli_presenti.items():
        if storico == "Totale": continue
        print(f"   -> {conteggio:5d} righe sono '{storico}'")

"""> Let's adjust categories in "**Settore Storico Cf Preval**", since many of them refer to the same macroarea.

> The following block focuses on lexical normalization and similarity-based deduplication.
Common abbreviations were systematically expanded (e.g. "art." in "articoli"; "x" in "per"), in order to improve lexical consistency before similarity matching and semantic categorization.
"""

COL = "clean_settore"
JARO_THRESHOLD = 0.88                 # soglia per clustering intra-bucket (dedup label)
JW_FALLBACK_THRESHOLD = 0.92          # soglia per fallback verso label pi vicina
TOP_CANDIDATES = 250
BLOCK_LEN = 4                         # blocking su prefisso per fallback


ABBREVIATIONS = {
    r"\bx\b": "per", r"\bx\.?\b": "per",
    r"\bart\b": "articoli", r"\bart\.\b": "articoli",
    r"\balim\b": "alimentari", r"\baliment\b": "alimentari",
    r"\bprod\b": "prodotti",
    r"\bapp\b": "apparecchiature", r"\bapparecch\b": "apparecchiature",
    r"\belettrodom\b": "elettrodomestici",
    r"\bsw\b": "software",
}

PLACEHOLDERS = { "NON SPECIFICATO", "SETTORE NON SPECIFICATO"}

def expand_abbreviations(s: str) -> str:
    if s is None:
        return s
    for pattern, repl in ABBREVIATIONS.items():
        s = re.sub(pattern, repl, s)
    return s

def normalize_text(x: object) -> str:
    if pd.isna(x):
        return np.nan
    s = str(x).lower().strip()

    # remove accents
    s = unicodedata.normalize("NFKD", s)
    s = "".join(c for c in s if not unicodedata.combining(c))

    # expand abbreviations
    s = expand_abbreviations(s)

    # remove parentheses
    s = re.sub(r"\(.*?\)", " ", s)

    # keep only letters/numbers/spaces
    s = re.sub(r"[^a-z0-9 ]+", " ", s)
    s = re.sub(r"\s+", " ", s).strip()
    return s if s else np.nan


# Normalize:
ese_dedup["settore_norm"] = ese_dedup[COL].apply(normalize_text)
# Neutral placeholders are excluded to avoid creating artificial clusters from "missing" labels:
mask_valid = (
    ese_dedup["settore_norm"].notna() &
    ~ese_dedup["settore_norm"].str.upper().isin(PLACEHOLDERS)
)

# frequenze su settore_norm
freq = ese_dedup.loc[mask_valid, "settore_norm"].value_counts(dropna=True)
unique_vals = freq.index.tolist()

print("Cardinality raw:", ese_dedup[COL].nunique(dropna=True))
print("Cardinality normalized (valid only):", ese_dedup.loc[mask_valid, "settore_norm"].nunique(dropna=True))


buckets = {}
for v in unique_vals:
    code = jellyfish.soundex(v)
    buckets.setdefault(code, []).append(v)

parent = {v: v for v in unique_vals}
rank = {v: 0 for v in unique_vals}

def find(a):
    while parent[a] != a:
        parent[a] = parent[parent[a]]
        a = parent[a]
    return a

def union(a, b):
    ra, rb = find(a), find(b)
    if ra == rb:
        return
    if rank[ra] < rank[rb]:
        parent[ra] = rb
    elif rank[ra] > rank[rb]:
        parent[rb] = ra
    else:
        parent[rb] = ra
        rank[ra] += 1

for code, vals in buckets.items():
    m = len(vals)
    if m <= 1:
        continue
    for i in range(m):
        v1 = vals[i]
        for j in range(i + 1, m):
            v2 = vals[j]
            jw = jellyfish.jaro_winkler_similarity(v1, v2)
            if jw >= JARO_THRESHOLD:
                union(v1, v2)

clusters = {}
for v in unique_vals:
    root = find(v)
    clusters.setdefault(root, []).append(v)

canon_map = {}
for root, members in clusters.items():
    members_sorted = sorted(members, key=lambda s: (-int(freq.get(s, 0)), len(s), s))
    canonical = members_sorted[0]
    for m in members:
        canon_map[m] = canonical


ese_dedup["settore_dedup"] = ese_dedup["settore_norm"]
ese_dedup.loc[mask_valid, "settore_dedup"] = ese_dedup.loc[mask_valid, "settore_norm"].map(canon_map)

print("Cardinality dedup (valid only):", ese_dedup.loc[mask_valid, "settore_dedup"].nunique(dropna=True))
merged_clusters = sum(1 for members in clusters.values() if len(members) > 1)
print("Merged clusters (>1 label):", merged_clusters)

# Debug: dedup non deve mai produrre etichette fuori dal dominio normalizzato valido
bad = set(ese_dedup.loc[mask_valid, "settore_dedup"].dropna().unique()) - set(ese_dedup.loc[mask_valid, "settore_norm"].dropna().unique())
print("Bad labels in settore_dedup (should be empty):", sorted(list(bad))[:50])

"""> The following block performs a semantic categorization, mapping the cleaned labels into a reduced set of business categories:"""

BAR_PATTERNS = [
    r"\bbar\b", r"\bcaffetteria\b", r"\bpub\b", r"\bbirreria\b", r"\bsnack\b", r"\btavola\s+fredda\b",
]
TAB_PATTERNS = [
    r"\btabacc?\w*", r"\bfumator\w*", r"\bmonopolio\b", r"\bsali\s+e\s+tabacch\w*", r"\blotto\b",
    r"\bricevitor\w*", r"\bvalori\s+bollati\b", r"\bprivativa\b",
]

OTHER_RULES = [
    ("tabaccheria", TAB_PATTERNS, "or"),
    ("bar", BAR_PATTERNS, "or"),

    ("arredamento", [
        r"\bmobil\w*", r"\barred\w*", r"\bcucin\w*", r"\bdivan\w*", r"\bpoltron\w*", r"\bmaterass\w*", r"\bcomplement\w*",
    ], "or"),

    ("alimentari", [
        r"\baliment\w*", r"\bgeneri\s+aliment\w*", r"\bcib\w*", r"\bminimercat\w*", r"\bminimarket\b", r"\bmarket\b",
        r"\bsupermercat\w*", r"\blatteri\w*", r"\blatticin\w*", r"\bcasear\w*", r"\bautogrill\b",
    ], "or"),

    ("abbigliamento", [
        r"\babbigl\w*", r"\bconfez\w*", r"\bsartori\w*", r"\bboutique\b", r"\babit\w*", r"\bcamic\w*",
    ], "or"),

    ("macchine utensili e forniture industriali", [
        r"\bmacchin\w*\s+utensil\w*", r"\bmacchinar\w*\s+industr\w*",r"\barticol\w*\s+per\s+l\s*industr\w*",
        r"\bfornitur\w*\s+industr\w*", r"\battrezzatur\w*\s+industr\w*",
    ], "or"),

    ("ottica", [
        r"\bottic\w*", r"\bfoto\s+ottic\w*", r"\bfoto\w*", r"\bottica\s+articol\w*\s+scientif\w*",
        r"\bcine[\s\-]*foto[\s\-]*ottic\w*[\s\-]*art\w*[\s\-]*scientif\w*",
    ], "or"),

    ("torrefazione", [r"\bcaff[e]\b"], "or"),

    ("enoteca e bevande", [
        r"\benotec\w*", r"\bvin\w*", r"\bliquor\w*", r"\bbevand\w*", r"\bbibit\w*", r"\balcol\w*",
        r"\bacet\w*", r"\bsuperalcolic\w*",
    ], "or"),

    ("ferramenta e edilizia", [
        r"\bferrament\w*", r"\bedil\w*", r"\bvernici\w*", r"\bidraulic\w*"
    ], "or"),

    ("farmacia ed erboristeria", [
        r"\bfarmac\w*", r"\berborist\w*", r"\bprodott\w*\s+natural\w*"
    ], "or"),

    ("gioielleria e orologeria", [
        r"\bgioiell\w*", r"\borolog\w*", r"\boro\b", r"\boreficeri\w*"
    ], "or"),

    ("giocattoli e modello", [
        r"\bgiocattol\w*", r"\bmodellism\w*", r"\bhobby\b", r"\bgioch\w*"
    ], "or"),

    ("oggettistica", [
        r"\barticol[io]\s+(da\s+)?regal\w*", r"\bgadget\b", r"\bregal\w*", r"\bposter\w*", r"\bbombonier\w*", r"\bcart\w*",
    ], "or"),

    ("panificio", [
        r"\bpane\b", r"\bforn\w*", r"\bpanific\w*", r"\bfocacc\w*", r"\bpizza\s+al\s+taglio\b"
    ], "or"),
]

# compile
BAR_RE = [re.compile(p, re.IGNORECASE) for p in BAR_PATTERNS]
TAB_RE = [re.compile(p, re.IGNORECASE) for p in TAB_PATTERNS]
OTHER_RE = [(cat, [re.compile(p, re.IGNORECASE) for p in pats], mode) for cat, pats, mode in OTHER_RULES]

def categorize_fixed(label):
    if pd.isna(label):
        return np.nan
    s = str(label).lower()

    # bar tabacchi = 1 match BAR + 1 match TAB
    if any(r.search(s) for r in BAR_RE) and any(r.search(s) for r in TAB_RE):
        return "bar tabacchi"

    # other rules: first match wins
    for cat, regs, mode in OTHER_RE:
        if mode == "or" and any(r.search(s) for r in regs):
            return cat

    return label

orig_upper = ese_dedup["settore_dedup"].astype("string").str.upper()
ese_dedup["settore_prevalente_regex"] = (
    ese_dedup["settore_dedup"].apply(categorize_fixed).astype("string").str.upper()
)

# righe non ricodificate
is_recoded = (ese_dedup["settore_prevalente_regex"] != orig_upper)

def block_key(s: str, n: int = BLOCK_LEN) -> str:
    s = re.sub(r"\s+", " ", str(s)).strip()
    return s[:n] if len(s) >= n else s

freq_dedup = orig_upper.value_counts(dropna=True)
anchors = freq_dedup.head(TOP_CANDIDATES).index.tolist()

anchor_buckets = {}
for a in anchors:
    anchor_buckets.setdefault(block_key(a), []).append(a)

def map_to_closest_anchor(label: object) -> object:
    if pd.isna(label):
        return np.nan
    s = str(label).upper().strip()

    candidates = anchor_buckets.get(block_key(s), anchors)

    best = s
    best_sim = -1.0
    for c in candidates:
        sim = jellyfish.jaro_winkler_similarity(s, c)
        if sim > best_sim:
            best_sim = sim
            best = c

    return best if best_sim >= JW_FALLBACK_THRESHOLD else s

ese_dedup["settore_prevalente"] = ese_dedup["settore_prevalente_regex"].copy()

mask = ~is_recoded
ese_dedup.loc[mask, "settore_prevalente"] = orig_upper[mask].apply(map_to_closest_anchor)


print("Cardinality settore_dedup:", orig_upper.nunique(dropna=True))
print("Cardinality settore_prevalente:", ese_dedup["settore_prevalente"].nunique(dropna=True))

changes = pd.DataFrame({
    "from": orig_upper[mask],
    "to": ese_dedup.loc[mask, "settore_prevalente"]
})
changes = changes[changes["from"] != changes["to"]]
print("Fallback remaps count:", len(changes))
print(changes.value_counts().head(30))

print("\nTop 60 settore_prevalente:")
print(ese_dedup["settore_prevalente"].value_counts(dropna=True).head(60))

"""> Some labels may remain missing after cleaning/categorization; thus we apply a final hierarchical fallback based on settore_merceologico.

"""

# Final missing handling: settore_prevalente (post-regex)
mask = ese_dedup["settore_prevalente"].isna()

ese_dedup.loc[
    mask & (ese_dedup["settore_merceologico"] == "ALIMENTARE"),
    "settore_prevalente"
] = "ALTRO ALIMENTARE"

ese_dedup.loc[
    mask & (ese_dedup["settore_merceologico"] == "NON ALIMENTARE"),
    "settore_prevalente"
] = "ALTRO NON ALIMENTARE"

ese_dedup["settore_prevalente"] = ese_dedup["settore_prevalente"].fillna("SETTORE NON SPECIFICATO")

# Check
ese_dedup["settore_prevalente"].isna().sum()

ese_dedup.groupby("settore_prevalente").size().sort_values(ascending=False).head(20)

"""> Fixing Settore Merceologico:"""

categorie_food = {
    "ALIMENTARI",
    "PANIFICIO",
    "PANETTERIA",
    "MACELLERIA",
    "SALUMERIA",
    "FRUTTA VERDURA E FUNGHI",
    "PASTICCERIA",
    "GELATERIA",
    "ROSTICCERIA",
    "DROGHERIA",
    "ENOTECA E BEVANDE",
    "BAR",
    "BAR TABACCHI",
    "TORREFAZIONE",
}

tabelle_speciali = [
    "TABELLA SPECIALE MONOPOLIO", "TABELLA SPECIALE FARMACIE",
    "TABELLA SPECIALE CARBURANTI", "AUTOMOBILI", "NON ALIMENTARE",
]

def correggi_macro_settore_prevalente(row):
    macro_orig = str(row["settore_merceologico"]).upper().strip()
    micro = str(row["settore_prevalente"]).upper().strip()

    # micro is FOOD -> macro has to be ALIMENTARE
    if micro in categorie_food:
        return "ALIMENTARE", (macro_orig != "ALIMENTARE")

    # macro is "tabella speciale"/non-food -> macro has to be NON ALIMENTARE
    if any(tab in macro_orig for tab in tabelle_speciali):
        return "NON ALIMENTARE", (macro_orig != "NON ALIMENTARE")

    #if macro_orig.startswith("ALIMENTARE"):
     #    return "ALIMENTARE", True

    return row["settore_merceologico"], False


ese_dedup["settore_merceologico_OLD"] = ese_dedup["settore_merceologico"]

risultati = ese_dedup.apply(correggi_macro_settore_prevalente, axis=1)
ese_dedup["settore_merceologico"] = [r[0] for r in risultati]
ese_dedup["Flag_Correzione"] = [r[1] for r in risultati]

print("New values for settore_merceologico column:\n")
print(ese_dedup["settore_merceologico"].value_counts(dropna=False))

"""**Let's show the overall columns now in dataset**"""

ese_dedup.columns

"""Removing redoundant columns:"""

cols_to_remove = ['settore_norm', 'settore_dedup', 'clean_settore','settore_merceologico_OLD', 'settore_prevalente_regex', 'Flag_Correzione']
ese_dedup = ese_dedup.drop(columns=cols_to_remove)
ese_dedup.columns

ese_dedup.shape

"""**Handling not exactly duplicated rows:**"""

# Definizione delle colonne che identificano il locale fisico
chiave_locale = ['tipo_via', 'via', 'civico', 'codice_via', 'zd', 'isolato', 'ingresso','accesso', 'settore_merceologico', 'settore_prevalente']

# Creiamo un conteggio delle occorrenze
conteggio = ese_dedup.groupby(chiave_locale, dropna=False).size().reset_index(name='Numero_Duplicati')

# Filtriamo per vedere solo quelli che appaiono pi di una volta
raddoppiati = conteggio[conteggio['Numero_Duplicati'] > 1].sort_values(by='Numero_Duplicati', ascending=False)

print(f"Ci sono {len(raddoppiati)} indirizzi che hanno pi di una riga associata.")
display(raddoppiati)

"""> Finding candidates with **Sorted Neighborhood**:"""

#indicizzo sulla via
indexer = recordlinkage.index.SortedNeighbourhood(on="via", window=9)
candidate_links = indexer.index(ese_dedup)
print(len(candidate_links))
candidate_links

"""> Comparing candidates:"""

compare_cl = recordlinkage.Compare()

# Exact compares:
compare_cl.exact('tipo_via', 'tipo_via', label='Tipo via')
compare_cl.exact('civico', 'civico', label='Civico')
compare_cl.exact('codice_via', 'codice_via', label='Codice via')
compare_cl.exact('zd', 'zd', label='ZD')
compare_cl.exact('settore_merceologico', 'settore_merceologico', label='Settore Merceologico')
compare_cl.exact('settore_prevalente', 'settore_prevalente', label='Settore')

# Not completely exact compares:
threshold = 0.90
compare_cl.string('via', 'via', method='jarowinkler', threshold=threshold, label='Via')

features = compare_cl.compute(candidate_links, ese_dedup)
features # For each column: 1 if the condition on that column is satisfied, 0 otherwise

features.describe()

# Counting the number of tuples that satisfy certain numbers of conditions
features.sum(axis=1).value_counts().sort_index(ascending=False)

matches = features[features.sum(axis=1) >= 7]

print(len(matches))
matches

# Creating a dataframe from the matches indexes
matching_pairs = matches.index.to_frame()
# For each index in the new dataframe created above, we print the matching rows and the numerber of conditions matched
for index in matching_pairs.head(100).index:
  num_matched_conditions = features.loc[index].sum()
  print(f"Match found between rows {index[0]} and {index[1]} (Matched conditions: {num_matched_conditions}):")
  display(ese_dedup.loc[[index[0], index[1]]])
  print()

def get_row_to_drop(row1, row2):
  # Define what we consider "empty" or "bad data":
  invalid_vals = {None, "Non specificata", "Non specificato"}

  # Check 'Insegna': we want to keep the one that is NOT NaN and NOT "Non specificata"
  val1 = ese_dedup.iloc[row1]["insegna"]
  val2 = ese_dedup.iloc[row2]["insegna"]

  # Check if row1 is "worse" than row2
  row1_insegna_invalid = pd.isna(val1) or val1 in invalid_vals
  row2_insegna_invalid = pd.isna(val2) or val2 in invalid_vals

  if row1_insegna_invalid and not row2_insegna_invalid:
      return row1
  if row2_insegna_invalid and not row1_insegna_invalid:
      return row2

  # Check 'superficie_totale':
  p1 = ese_dedup.iloc[row1]["superficie_totale"]
  p2 = ese_dedup.iloc[row2]["superficie_totale"]

  if p1 == 0:
    return row1
  if p2 == 0:
    return row2

  # If both are equally good (or equally bad), drop the second one
  return row2

def get_gauss_score(v1, v2, scale):
    # Calculates Gaussian similarity between two numbers:
    if pd.isna(v1) or pd.isna(v2):
        return 0.0
    distance = abs(v1 - v2)
    return np.exp(-0.5 * (distance / scale)**2)

def get_jw_score(s1, s2):
    # Handle NaNs: if either is missing, similarity is 0
    if pd.isna(s1) and pd.isna(s2):
        return 1.0
    if pd.isna(s1) or pd.isna(s2):
        return 0.0
    return jellyfish.jaro_winkler_similarity(str(s1), str(s2))

ese_dedup_drop = ese_dedup.copy()
dropped_indexes = set()
JW_THRESHOLD = 0.85
GAUSS_THRESHOLD = 0.60   # Numerical similarity (roughly distance <= scale)
SCALE = 20

for i in matches.index:
  idx1, idx2 = i[0], i[1]

  if idx1 in dropped_indexes or idx2 in dropped_indexes:
        continue

  row1 = ese_dedup.loc[idx1]
  row2 = ese_dedup.loc[idx2]

  insegna_score = get_jw_score(row1['insegna'], row2['insegna'])
  superficie_score = get_gauss_score(row1['superficie_totale'], row2['superficie_totale'], scale=SCALE)

  # Getting the index of the row to drop
  # If insegna_score is enough we consider it a match and check which column to drop
  if insegna_score >= JW_THRESHOLD:
    row_to_drop = get_row_to_drop(idx1, idx2)

  # if insegna_score wasn't enough we check if one of the two value was NA, if so we check on superficie_totale otherwise it wasn't a match
  elif (pd.isna(row1['insegna']) or pd.isna(row2['insegna'])) and superficie_score >= GAUSS_THRESHOLD:
    row_to_drop = get_row_to_drop(idx1, idx2)


    if row_to_drop in ese_dedup_drop.index:
      ese_dedup_drop = ese_dedup_drop.drop(row_to_drop)
      dropped_indexes.add(row_to_drop)

ese_dedup_drop.reset_index(drop=True, inplace=True)
ese_dedup_drop

ese_dedup = ese_dedup_drop.copy()
ese_dedup.shape

"""### **Outliers Detection**"""

# Inspecting the possible columns on which we can perform Outliers detection:
columns = list(ese_dedup.columns)
types = list(ese_dedup.dtypes)
for i in range(len(columns)):
  print(f"{columns[i]} : {types[i]}")

"""By analyzing all the columns that remained in the dataset, columns for which make sense perform an Outliers detection are the Superficie-related columns, since:
- Codice via: numeric value that is used as an identifier of the street, and therefore it does not represent a "measure" in which we can find outliers
- Isolato/Zd: numeric values that are used as an identifier of an urban area, and therefore not represent a "measure" in which we can find outliers

"""

cols_outliers = [ "superficie_vendita", "superficie_totale", "superficie_altri_usi", "superficie_tabelle_speciali"]
for c in cols_outliers:
    plt.figure()
    ese_dedup.boxplot(column=c)
    plt.title(f"Boxplot - {c}")
    plt.ylabel(c)
    plt.show()

"""Outlier detection was performed using the Interquartile Range (IQR) method within each prevalent sector.
This choice was motivated by the strong heterogeneity in typical surface sizes across different commercial sectors: a value that may be considered extreme in one sector can be perfectly normal in another
"""

# IQR statistics per column:
iqr_bounds = {}

for c in cols_outliers:
    s = ese_dedup[c].dropna()
    q1, q3 = s.quantile([0.25, 0.75])
    iqr = q3 - q1
    upper = q3 + 1.5 * iqr

    iqr_bounds[c] = {"Q1": q1, "Q3": q3, "IQR": iqr, "upper": upper}

pd.DataFrame(iqr_bounds).T

# Boolean Flag for global outliers (non si rimuovono i valori, si segnano soltanto)
for c in cols_outliers:
    upper = iqr_bounds[c]["upper"]
    ese_dedup[f"flag_outlier_{c}"] = ese_dedup[c] > upper

# Counting ouliers per column:
for c in cols_outliers:
    print(c, ese_dedup[f"flag_outlier_{c}"].sum())

# Check plausible values
for c in cols_outliers:
    print(f"\nTop 15 outlier per {c}")
    display(
        ese_dedup.loc[ese_dedup[f"flag_outlier_{c}"],
                      ["settore_prevalente"] + cols_outliers]
        .sort_values(c, ascending=False)
        .head(15)
    )

"""Outliers are detected using the IQR method applied separately within each *settore_prevalente*, in order to account for sector-specific differences in typical surface sizes. \
Detected outliers were flagged but not removed, as they may correspond to legitimately large commercial establishments
"""

min_group_size = 30

for c in cols_outliers:
    ese_dedup[f"flag_outlier_{c}_by_settore"] = False

    for settore, g in ese_dedup.groupby("settore_prevalente"):
        s = g[c].dropna()
        if len(s) < min_group_size:
            continue

        q1, q3 = s.quantile([0.25, 0.75])
        iqr = q3 - q1
        upper = q3 + 1.5 * iqr

        idx = g[g[c] > upper].index
        ese_dedup.loc[idx, f"flag_outlier_{c}_by_settore"] = True

# counting:
for c in cols_outliers:
    print(c, ese_dedup[f"flag_outlier_{c}_by_settore"].sum())

summary = []

for c in cols_outliers:
    n_tot = ese_dedup[c].notna().sum()
    n_out_glob = ese_dedup[f"flag_outlier_{c}"].sum()
    n_out_sett = ese_dedup[f"flag_outlier_{c}_by_settore"].sum()

    summary.append({
        "colonna": c,
        "n_non_null": n_tot,
        "outliers_IQR_global": int(n_out_glob),
        "outliers_IQR_by_settore": int(n_out_sett),
        "pct_out_global": round(100 * n_out_glob / n_tot, 3) if n_tot else np.nan,
        "pct_out_by_settore": round(100 * n_out_sett / n_tot, 3) if n_tot else np.nan
    })

pd.DataFrame(summary)

# Final flag finale, stating if a record is an outlier at least for one "superficie" (per settore)
outlier_flags_final = [f"flag_outlier_{c}_by_settore" for c in cols_outliers]

ese_dedup["flag_any_outlier_surface"] = (ese_dedup[outlier_flags_final].any(axis=1))

# Final distribution
ese_dedup["flag_any_outlier_surface"].value_counts()

"""Removing debug fields:"""

debug_columns = ['flag_outlier_superficie_vendita', 'flag_outlier_superficie_totale',
                 'flag_outlier_superficie_altri_usi','flag_outlier_superficie_tabelle_speciali',
                 'flag_outlier_superficie_vendita_by_settore', 'flag_outlier_superficie_totale_by_settore',
                'flag_outlier_superficie_altri_usi_by_settore', 'flag_outlier_superficie_tabelle_speciali_by_settore',
       'flag_any_outlier_surface']
ese_dedup = ese_dedup.drop(columns=debug_columns)
ese_dedup.columns

"""### Final overall Standardization
After all steps we perform a final standardization of records:
"""

# Final standardization
text_cols = ese_dedup.select_dtypes(include=["object", "string"]).columns

#convert float in int
float_cols = ese_dedup.select_dtypes(include=["float"]).columns
ese_dedup[float_cols] = ese_dedup[float_cols].astype(int)

# MAIUSC
for col in text_cols:
    ese_dedup[col] = ese_dedup[col].str.upper()

ese_dedup.dtypes

ese_dedup.head(10)

"""## **Data quality assessment (after cleaning)**"""

# Number of rows after cleaning the dataset
print(f"Number of rows after cleaning the dataset: {ese_dedup.shape[0]}")

"""Null values"""

# Display the number of NULL values for each column
NULL_VAL_PER_COL = ese_dedup.isnull().sum()
print(f"Number of NULL values for each column:\n{NULL_VAL_PER_COL}")

"""Completeness evaluation"""

TOT = ese_dedup.shape[0]*ese_dedup.shape[1]
NOT_NULL = ese_dedup.count().sum()
# Computing the ratio between the number of NOT NULL cells with the total number of cells
COMPLETENESS = NOT_NULL/TOT

# Display the percentage of NOT NULL tuples in the dataset (w.r.t the total number of cells in the same dataset)
COMPLETENESS_percentage = '{0:.1f}%'.format(COMPLETENESS*100)
print(f"COMPLETENESS: {COMPLETENESS_percentage}")

"""Accuracy evaluation"""

# ZD
ZD_domain = [1,2,3,4,5,6,7,8,9]
correct_ZD = ese_dedup['zd'].isin(ZD_domain).sum()
not_null_ZD = ese_dedup['zd'].count()
accuracy = correct_ZD/not_null_ZD
print(f"Accuracy of the ZD column: {accuracy*100}%")

# 'Codice via' - the code have less than 4 digits
correct_codice_via = (ese_dedup['codice_via'] <= 9999).sum()
not_null_codice_via = ese_dedup['codice_via'].count()
accuracy = correct_codice_via/not_null_codice_via
print(f"Accuracy of the Codice via column: {accuracy*100}%")

"""Consistency evaluation"""

PROPERTIES = ["Consistency Superficie Totale"]
CLEAN_DF = ese_dedup.copy()

# Adding the new columns and populate the rows with '1' if the check has been passed, with '0' otherwise
# N.B: In case the processed row contains a NULL value, in the consistency column we decided to put a '0' value
CLEAN_DF[PROPERTIES[0]] = np.where(CLEAN_DF['superficie_totale']>0.0,
                                      1,
                                      0)
CLEAN_DF

for cons in PROPERTIES:
  # Retrieving the column name present in the original dataset
  COL_NAME = cons.split("Consistency ")[1]
  CONSISTENT_CELLS = (CLEAN_DF[cons] == 1).sum()

  TOTAL_CELLS = CLEAN_DF.shape[0]

  CONSISTENCY = CONSISTENT_CELLS / TOTAL_CELLS
  CONSISTENCY = '{0:.1f}%'.format(CONSISTENCY * 100)
  print(f"{cons}: " + CONSISTENCY)

"""Uniqueness, distinctness and constancy evaluation for each column"""

for col in ese_dedup.columns:
  print("DQ Assesment for "+ col + ":")

  # Computing the number of distinct values in the column "col"
  NUM_DISTINCT = ese_dedup[col].nunique()
  # Computing the number of NOT NULL values in the column "col"
  COUNT = ese_dedup[col].count()
  # Computing the total number of rows in the dataset
  ROWS = ese_dedup.shape[0]
  # Computing the uniqueness of the column "col"
  UNIQUENESS = NUM_DISTINCT / ROWS
  print("UNIQUENESS: ", UNIQUENESS)

  # Computing the distinctness
  DISTINCTNESS = NUM_DISTINCT / COUNT
  print("DISTINCTNESS: ", DISTINCTNESS)

  # Retrieving the highest number of times that a distinct value appear in a tuple of the column "col"
  MAX_COUNTS = max(ese_dedup[col].value_counts())
  # Computing the constancy
  CONSTANCY = MAX_COUNTS / COUNT
  print("CONSTANCY: ", CONSTANCY)

  print("\n")

"""# **Data Analysis**

In this analysis, we address a **supervised regression** problem with the goal of predicting the total surface area of commercial establishments.
The target variable is Superficie Totale, a numerical variable representing the overall size (in square meters) of each activity.

The features selected are:
* Tipo via: describing the typology of the street.
* Codice via: street-level identifier.
* ZD: urban zoning classification.
* Settore Storico Cf Preval: type of activity.
* Settore Merceologico: commercial category of the activity.

In order to avoid data leakage, all surface-related variables other than the target were explicitly excluded from the analysis.

## Dirty dataset analysis

**Data Preprocessing**
"""

#dataset considered
dataset = ese.copy()
#target definition
target = "Superficie Totale"
#feature definition
feature_cols = feature_cols = [ "ZD",
                                "Settore Storico Cf Preval",
                                "Tipo via",
                                "Codice via",
                                "Settore Merceologico" ]

X = dataset[1:][feature_cols] # Features
y = dataset[1:][target] # Target variable

# Drop rows where y is missing/invalid
mask = y.notna() & (y >= 0)
X = X.loc[mask].copy()
y = y.loc[mask].copy()

#encoding of categorical columns
def encode(original_dataframe, feature_to_encode):
  dummies = pd.get_dummies(original_dataframe[[feature_to_encode]], dummy_na=True)
  res = pd.concat([original_dataframe, dummies], axis=1)
  res = res.drop([feature_to_encode], axis=1)
  return (res)

categorical_columns=list(X.select_dtypes(include=['bool','object']).columns)

for col in X.columns:
    if col in categorical_columns:
        X = encode(X,col)

X = StandardScaler().fit_transform(X)
X = np.nan_to_num(X)

#Split of data in traing data and test data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

"""**Model definition**"""

ridge = Ridge(alpha=1.0, random_state=42)

"""**Model training**"""

ridge.fit(X_train, y_train)

"""**Model testing**"""

y_pred_ridge = ridge.predict(X_test)

mse_r = mean_squared_error(y_test, y_pred_ridge)
rmse_r = np.sqrt(mse_r)
mae_r = mean_absolute_error(y_test, y_pred_ridge)

print("=== RIDGE ===")
print("MSE :", mse_r)
print("RMSE:", rmse_r)
print("MAE :", mae_r)
print()

"""## Clean dataset analysis

**Data Preprocessing**

For the analysis on the cleaned data, we used the same features as in the analysis on the raw dataset, but with the necessary preprocessing and cleaning transformations applied.
"""

#dataset considered
dataset = ese_dedup.copy()
#target definition
target = "superficie_totale"
#feature definition
feature_cols = feature_cols = [ "zd",
                                "settore_prevalente",
                                "tipo_via",
                                "codice_via",
                                "settore_merceologico" ]

X = dataset[1:][feature_cols] # Features
y = dataset[1:][target] # Target variable

# Drop rows where y is missing/invalid
mask = y.notna() & (y >= 0)
X = X.loc[mask].copy()
y = y.loc[mask].copy()

#encoding of categorical columns
def encode(original_dataframe, feature_to_encode):
  dummies = pd.get_dummies(original_dataframe[[feature_to_encode]], dummy_na=True)
  res = pd.concat([original_dataframe, dummies], axis=1)
  res = res.drop([feature_to_encode], axis=1)
  return (res)

categorical_columns=list(X.select_dtypes(include=['bool','object', 'string']).columns)

for col in X.columns:
    if col in categorical_columns:
        X = encode(X,col)

X = StandardScaler().fit_transform(X)
X = np.nan_to_num(X)

#Split of data in traing data and test data
X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, random_state=42
)

"""**Model definition**"""

ridge = Ridge(alpha=1.0, random_state=42)

"""**Model training**"""

ridge.fit(X_train, y_train)

"""**Model testing**"""

y_pred_ridge = ridge.predict(X_test)

mse_r = mean_squared_error(y_test, y_pred_ridge)
rmse_r = np.sqrt(mse_r)
mae_r = mean_absolute_error(y_test, y_pred_ridge)

print("=== RIDGE ===")
print("MSE :", mse_r)
print("RMSE:", rmse_r)
print("MAE :", mae_r)
print()

"""# Dataset export"""

ese_dedup.to_csv('cleaned_dataset.csv', index=False, sep=";", encoding="utf_8_sig")